---
title: "Harmonized Drug Dataset"
author: "James Bannon, Michael Tran"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  fig.width = 7,
  fig.height = 5
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(digits = 3)
```

# Overview

This report is a quality control walkthrough for the Harmonized Drug Dataset (HDD)
stored as a `MultiAssayExperiment` (MAE). The dataset harmonizes multiple drug-related
assays and features across a shared compound universe (PubChem CID) so downstream analyses
can operate on a consistent sample space.

## Data Sources

The MAE is constructed in `workflow/scripts/construct_MAE.R`. It pulls processed experiments
from `data/procdata/experiments/` and a `colData` table from `data/procdata/colData.csv`.
Key sources (from `config/pipeline.yaml` and the workflow scripts) include:

- **BindingDB**: downloaded from the BindingDB site; filtered to human targets and cleaned, then transformed to a CID-by-target affinity
  matrix.
- **DeepChem datasets** (Tox21, ToxCast, SIDER, ClinTox): downloaded from DeepChem S3, then re-shaped to CID-by-assay matrices.
- **Bioassays**: pulled from the BHKLab AnnotationDB alongside compound metadata, then filtered to gold-standard assays.
- **Fingerprints**: RDKit Morgan count fingerprints generated from SMILES.

# Load HDD

```{r load-data}
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(Matrix)
library(ggplot2)
library(dplyr)
library(tidyr)
library(glmnet)

hdd <- readRDS("data/results/hdd.RDS")
hdd
```

# MAE snapshot

```{r mae-snapshot}
experiment_names <- names(experiments(hdd))
experiment_names

summarize_experiment <- function(se) {
  assay_obj <- assays(se)[[1]]
  data_class <- class(assay_obj)[1]
  dims <- dim(assay_obj)
  missing_fraction <- if (is.numeric(assay_obj) || is.logical(assay_obj)) {
    mean(is.na(assay_obj))
  } else {
    mean(is.na(as.vector(assay_obj)))
  }

  data.frame(
    assay_name = assayNames(se)[1],
    rows = dims[1],
    cols = dims[2],
    data_class = data_class,
    missing_fraction = missing_fraction,
    stringsAsFactors = FALSE
  )
}

experiment_summary <- do.call(
  rbind,
  lapply(experiments(hdd), summarize_experiment)
)
rownames(experiment_summary) <- experiment_names
experiment_summary
```

Basic sanity checks for sampleMap completeness.

```{r samplemap-checks}
# Basic sampleMap sanity checks
all_in_coldata <- lapply(experiments(hdd), function(se) {
  all(colnames(se) %in% rownames(colData(hdd)))
})
if (all(unlist(all_in_coldata))) {
  print("All experiments map cleanly to colData.")
} else {
  print("Some experiments contain samples missing from colData:")
  print(all_in_coldata[!unlist(all_in_coldata)])
}

# Any missing samples per experiment (only report issues)
missing_samples <- lapply(experiments(hdd), function(se) {
  setdiff(colnames(se), rownames(colData(hdd)))
})
missing_samples <- missing_samples[lengths(missing_samples) > 0]
if (length(missing_samples) == 0) {
  print("No missing samples detected in any experiment.")
} else {
  print("Missing samples by experiment:")
  print(missing_samples)
}
```

# colData overview

```{r coldata-overview}
cd <- colData(hdd)
cd[1:5, 1:min(10, ncol(cd))]

# Quick missingness scan
missing_by_field <- sapply(cd, function(x) {
  mean(is.na(x))
})
missing_by_field
```

```{r coldata-basic-stats}
# Distinct counts for key identifiers
c(
  n_compounds = nrow(cd),
  unique_cids = length(unique(cd$`Pubchem.CID`))
)
```

# Experiment walkthroughs

Below, each experiment in the HDD MAE is reviewed.

## BindingDB

A compound-by-target affinity matrix derived from BindingDB. Rows correspond
to protein targets and columns are PubChem CIDs. Values are affinity measurements in nM.

```{r bindingdb-preview}
se <- experiments(hdd)[["BindingDB"]]
assay_mat <- assay(se)

# Dimensions and a small preview
c(rows = nrow(assay_mat), cols = ncol(assay_mat))
assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))]
```

```{r bindingdb-qc}
# Missingness by target and compound
row_missing <- rowMeans(is.na(assay_mat))
col_missing <- colMeans(is.na(assay_mat))
summary(row_missing)
summary(col_missing)

# Value distribution (numeric only)
summary(as.numeric(assay_mat))
```

```{r bindingdb-plots, fig.height=5, fig.width=8}
bindingdb_missing <- tibble::tibble(
  missing_fraction = c(row_missing, col_missing),
  axis = rep(c("Target", "Compound"), c(length(row_missing), length(col_missing)))
)

ggplot(bindingdb_missing, aes(x = missing_fraction, fill = axis)) +
  geom_histogram(bins = 30, alpha = 0.7, position = "identity") +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "BindingDB missingness by target vs compound",
    x = "Missing fraction",
    y = "Count",
    fill = ""
  ) +
  theme_minimal()

bindingdb_vals <- as.numeric(assay_mat)
bindingdb_vals <- bindingdb_vals[!is.na(bindingdb_vals) & bindingdb_vals > 0]

ggplot(tibble::tibble(log10_affinity = log10(bindingdb_vals)), aes(x = log10_affinity)) +
  geom_histogram(bins = 50, fill = "#3A6EA5", alpha = 0.8) +
  labs(
    title = "BindingDB affinity values (log10 nM)",
    x = "log10(affinity nM)",
    y = "Count"
  ) +
  theme_minimal()
```

TODO: Seems BindingDB data is really sparse, is this intended?
TODO: Huge distribution of values, that max doesn't look right.

## Bioassays

A compound-by-assay matrix of PubChem bioassay outcomes. Rows are AIDs
(assay identifiers) and columns are PubChem CIDs. Entries are categorical (Active,
Inactive, Not Measured).

```{r bioassays-preview}
se <- experiments(hdd)[["Bioassays"]]
assay_mat <- assay(se)

c(rows = nrow(assay_mat), cols = ncol(assay_mat))
assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))]
```

```{r bioassays-qc}
# Category counts
assay_mat_chr <- as.matrix(assay_mat)
assay_values <- as.character(assay_mat_chr)
category_counts <- sort(table(assay_values, useNA = "ifany"), decreasing = TRUE)
category_counts

# Missingness proxy: Not Measured rate per assay
not_measured_rate <- rowMeans(assay_mat_chr == "Not Measured")
summary(not_measured_rate)
```

```{r bioassays-plots, fig.height=6, fig.width=8}
bio_long <- as.data.frame(assay_mat_chr) %>%
  tibble::rownames_to_column("assay") %>%
  tidyr::pivot_longer(-assay, names_to = "compound", values_to = "status")
bio_long$status <- factor(bio_long$status, levels = c("Active", "Inactive", "Not Measured"))

ggplot(bio_long, aes(x = status)) +
  geom_bar(fill = "#4C78A8") +
  labs(
    title = "Bioassays overall category counts",
    x = "Outcome",
    y = "Count"
  ) +
  theme_minimal()

ggplot(bio_long, aes(x = assay, fill = status)) +
  geom_bar(position = "fill") +
  coord_flip() +
  labs(
    title = "Bioassays outcome composition by assay",
    x = "Assay (AID)",
    y = "Fraction",
    fill = ""
  ) +
  theme_minimal()
```

## Tox21

A compound-by-assay matrix for the Tox21 panel. Rows are Tox21 assays and
columns are PubChem CIDs. Values are typically binary (0/1) with missing values for
unmeasured compounds.

```{r tox21-preview}
se <- experiments(hdd)[["Tox21"]]
assay_mat <- assay(se)

c(rows = nrow(assay_mat), cols = ncol(assay_mat))
assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))]
```

```{r tox21-qc}
# Value distribution
assay_mat_num <- as.matrix(assay_mat)
if ("mol_id" %in% rownames(assay_mat_num)) {
  assay_mat_num <- assay_mat_num[rownames(assay_mat_num) != "mol_id", , drop = FALSE]
}
table(as.vector(assay_mat_num), useNA = "ifany")

# Missingness per assay
summary(rowMeans(is.na(assay_mat_num)))
```

```{r tox21-plots, fig.height=5, fig.width=8}
tox21_long <- as.data.frame(assay_mat_num) %>%
  tibble::rownames_to_column("assay") %>%
  tidyr::pivot_longer(-assay, names_to = "compound", values_to = "value")
tox21_long$value_factor <- factor(tox21_long$value, levels = c(0, 1))

ggplot(tox21_long, aes(x = compound, y = assay, fill = value_factor)) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("0" = "#d1d5db", "1" = "#2563eb"), na.value = "#f3f4f6") +
  labs(
    title = "Tox21 outcomes (0/1) by assay and compound",
    x = "Compound",
    y = "Assay",
    fill = ""
  ) +
  theme_minimal()

tox21_rate <- tox21_long %>%
  group_by(assay) %>%
  summarize(positive_rate = mean(value == 1, na.rm = TRUE), .groups = "drop")

ggplot(tox21_rate, aes(x = reorder(assay, positive_rate), y = positive_rate)) +
  geom_col(fill = "#4C78A8") +
  coord_flip() +
  labs(
    title = "Tox21 positive rate by assay",
    x = "Assay",
    y = "Positive rate"
  ) +
  theme_minimal()
```

## ToxCast

A compound-by-assay matrix for the ToxCast panel. Rows are assay endpoints
and columns are PubChem CIDs. Values are typically binary (0/1) with missing values.

```{r toxcast-preview}
se <- experiments(hdd)[["ToxCast"]]
assay_mat <- assays(se)[[1]]

c(rows = nrow(assay_mat), cols = ncol(assay_mat))
assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))]
```

```{r toxcast-qc}
# Value distribution
assay_mat_num <- as.matrix(assay_mat)
table(as.vector(assay_mat_num), useNA = "ifany")

# Missingness per assay
summary(rowMeans(is.na(assay_mat_num)))
```

```{r toxcast-plots, fig.height=5, fig.width=8}
toxcast_counts <- as.data.frame(table(value = as.vector(assay_mat_num), useNA = "ifany"))

ggplot(toxcast_counts, aes(x = value, y = Freq)) +
  geom_col(fill = "#4C78A8") +
  labs(
    title = "ToxCast value counts",
    x = "Value",
    y = "Count"
  ) +
  theme_minimal()

row_non_missing <- rowSums(!is.na(assay_mat_num))
row_positive <- rowSums(assay_mat_num == 1, na.rm = TRUE)
row_rate <- row_positive / row_non_missing
row_rate <- row_rate[!is.na(row_rate)]

ggplot(tibble::tibble(positive_rate = row_rate), aes(x = positive_rate)) +
  geom_histogram(bins = 30, fill = "#3A6EA5", alpha = 0.8) +
  labs(
    title = "ToxCast positive rate by assay",
    x = "Positive rate",
    y = "Assay count"
  ) +
  theme_minimal()

col_non_missing <- colSums(!is.na(assay_mat_num))
col_positive <- colSums(assay_mat_num == 1, na.rm = TRUE)
col_rate <- col_positive / col_non_missing
toxcast_compound <- tibble::tibble(
  compound = colnames(assay_mat_num),
  positive_rate = as.numeric(col_rate)
)

ggplot(toxcast_compound, aes(x = compound, y = positive_rate)) +
  geom_col(fill = "#72B7B2") +
  labs(
    title = "ToxCast positive rate by compound",
    x = "Compound",
    y = "Positive rate"
  ) +
  theme_minimal()
```

## ClinTox

A compound-by-label matrix for clinical toxicity outcomes. Rows correspond
to the ClinTox labels (e.g., FDA approval and toxicity) and columns are PubChem CIDs.
Values are binary (0/1) with missing values for compounds not present in the source dataset.

```{r clintox-preview}
se <- experiments(hdd)[["ClinTox"]]
assay_mat <- assay(se)

c(rows = nrow(assay_mat), cols = ncol(assay_mat))
assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))]
```

```{r clintox-qc}
# Value distribution
assay_mat_num <- as.matrix(assay_mat)
table(as.vector(assay_mat_num), useNA = "ifany")

# Missingness per label
summary(rowMeans(is.na(assay_mat_num)))
```

```{r clintox-plots, fig.height=5, fig.width=8}
clintox_counts <- as.data.frame(table(value = as.vector(assay_mat_num), useNA = "ifany"))

ggplot(clintox_counts, aes(x = value, y = Freq)) +
  geom_col(fill = "#4C78A8") +
  labs(
    title = "ClinTox value counts",
    x = "Value",
    y = "Count"
  ) +
  theme_minimal()

row_non_missing <- rowSums(!is.na(assay_mat_num))
row_positive <- rowSums(assay_mat_num == 1, na.rm = TRUE)
row_rate <- row_positive / row_non_missing

clintox_label <- tibble::tibble(
  label = rownames(assay_mat_num),
  positive_rate = as.numeric(row_rate)
)

ggplot(clintox_label, aes(x = reorder(label, positive_rate), y = positive_rate)) +
  geom_col(fill = "#72B7B2") +
  coord_flip() +
  labs(
    title = "ClinTox positive rate by label",
    x = "Label",
    y = "Positive rate"
  ) +
  theme_minimal()

col_non_missing <- colSums(!is.na(assay_mat_num))
col_positive <- colSums(assay_mat_num == 1, na.rm = TRUE)
col_rate <- col_positive / col_non_missing

ggplot(tibble::tibble(positive_rate = col_rate), aes(x = positive_rate)) +
  geom_histogram(bins = 30, fill = "#3A6EA5", alpha = 0.8) +
  labs(
    title = "ClinTox positive rate across compounds",
    x = "Positive rate",
    y = "Compound count"
  ) +
  theme_minimal()
```

## SIDER

A compound-by-side-effect matrix derived from SIDER. Rows are side effect
categories and columns are PubChem CIDs. Values are binary (0/1) with missing values when
a compound is not represented.

```{r sider-preview}
se <- experiments(hdd)[["SIDER"]]
assay_mat <- assay(se)

c(rows = nrow(assay_mat), cols = ncol(assay_mat))
assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))]
```

```{r sider-qc}
# Value distribution
assay_mat_num <- as.matrix(assay_mat)
table(as.vector(assay_mat_num), useNA = "ifany")

# Missingness per side effect
summary(rowMeans(is.na(assay_mat_num)))
```

```{r sider-plots, fig.height=6, fig.width=8}
sider_counts <- as.data.frame(table(value = as.vector(assay_mat_num), useNA = "ifany"))

ggplot(sider_counts, aes(x = value, y = Freq)) +
  geom_col(fill = "#4C78A8") +
  labs(
    title = "SIDER value counts",
    x = "Value",
    y = "Count"
  ) +
  theme_minimal()

row_non_missing <- rowSums(!is.na(assay_mat_num))
row_positive <- rowSums(assay_mat_num == 1, na.rm = TRUE)
row_rate <- row_positive / row_non_missing

sider_effects <- tibble::tibble(
  side_effect = rownames(assay_mat_num),
  positive_rate = as.numeric(row_rate)
)

ggplot(sider_effects, aes(x = reorder(side_effect, positive_rate), y = positive_rate)) +
  geom_col(fill = "#72B7B2") +
  coord_flip() +
  labs(
    title = "SIDER positive rate by side effect",
    x = "Side effect",
    y = "Positive rate"
  ) +
  theme_minimal()

col_non_missing <- colSums(!is.na(assay_mat_num))
col_positive <- colSums(assay_mat_num == 1, na.rm = TRUE)
col_rate <- col_positive / col_non_missing

ggplot(tibble::tibble(positive_rate = col_rate), aes(x = positive_rate)) +
  geom_histogram(bins = 30, fill = "#3A6EA5", alpha = 0.8) +
  labs(
    title = "SIDER positive rate across compounds",
    x = "Positive rate",
    y = "Compound count"
  ) +
  theme_minimal()
```

## Fingerprints (Morgan count fingerprints)

Count-based Morgan fingerprints generated from SMILES for each compound using RDKit.
Each fingerprint experiment is stored as a sparse matrix of feature counts with rows as
fingerprint bins and columns as PubChem CIDs.

```{r fingerprints-discovery}
fp_names <- grep("^fingerprint\\.", experiment_names, value = TRUE)
fp_names
```

```{r fingerprints-preview}
for (fp_name in fp_names) {
  se <- experiments(hdd)[[fp_name]]
  assay_mat <- assays(se)[[1]]

  cat("\nFingerprint:", fp_name, "\n")
  cat("Dimensions:", nrow(assay_mat), "x", ncol(assay_mat), "\n")

  # Sparsity for sparse matrices
  if (inherits(assay_mat, "sparseMatrix")) {
    sparsity <- 1 - Matrix::nnzero(assay_mat) / length(assay_mat)
    cat("Sparsity:", round(sparsity, 4), "\n")
  }

  print(assay_mat[1:min(5, nrow(assay_mat)), 1:min(6, ncol(assay_mat))])
}
```

```{r fingerprints-plots, fig.height=5, fig.width=8}
for (fp_name in fp_names) {
  se <- experiments(hdd)[[fp_name]]
  assay_mat <- assays(se)[[1]]

  col_nnz <- Matrix::colSums(assay_mat > 0)
  row_nnz <- Matrix::rowSums(assay_mat > 0)

  nnz_df <- tibble::tibble(
    count = c(as.numeric(col_nnz), as.numeric(row_nnz)),
    axis = rep(c("Compound", "Feature"), c(length(col_nnz), length(row_nnz)))
  )

  p_nnz <- ggplot(nnz_df, aes(x = count, fill = axis)) +
    geom_histogram(bins = 30, alpha = 0.7, position = "identity") +
    scale_fill_brewer(palette = "Set2") +
    labs(
      title = paste("Fingerprint non-zero counts:", fp_name),
      x = "Non-zero features per entity",
      y = "Count",
      fill = ""
    ) +
    theme_minimal()

  nonzero_vals <- assay_mat@x
  val_df <- as.data.frame(table(value = nonzero_vals))

  p_vals <- ggplot(val_df, aes(x = value, y = Freq)) +
    geom_col(fill = "#3A6EA5") +
    labs(
      title = paste("Fingerprint count values:", fp_name),
      x = "Count value",
      y = "Frequency"
    ) +
    theme_minimal()

  print(p_nnz)
  print(p_vals)
}
```


## Computing with Morgan Fingerprints


We now turn to a machine learning task. We will be trying to predict the drugs mechanism of action (MOA) from the drug structures as stored in the fingerprints. Specifically we will try to classify drugs by how likely they are to cause liver injury based on their Drug Induced Liver Injury (DILI) severity score. First lets look at the counts of the scores:

```{r moa-counts}
col.Data <- colData(hdd) %>% as.data.frame() 
table(col.Data$DILI.Severity)
```

We will frame predicting DILI severity as a binary classification problem. To this we will subset the data into high DILI scores (scores of 7 or 8) and low DILI (scores of 2 or 3). 

```{r dili-subsetting}
high.scores <- c(7,8)
low.scores <- c(2,3)

dili.High <- col.Data %>% filter(DILI.Severity %in% high.scores) %>% select(Pubchem.CID)
dili.Low <- col.Data %>% filter(DILI.Severity %in% low.scores) %>% select(Pubchem.CID)
```


Now lets make training and testing datasts using the Morgan fingerprint with radius 3 and with 512 bits. The training set will be 80% of the data we have. 

```{r making-fp-data}
set.seed(1234)

fps <- assays(hdd)[["fingerprint.Morgan.3.512"]]

high.fps <- as.matrix(t(fps[,as.character(dili.High$Pubchem.CID)]))
low.fps <- as.matrix(t(fps[,as.character(dili.Low$Pubchem.CID)]))

X <- rbind(high.fps, low.fps)
rownames(X)<-NULL
y <- c( rep(1,dim(high.fps)[1]), rep(0,dim(low.fps)[1]))

split.idx <- sample(c(TRUE, FALSE), dim(X)[1], replace=TRUE, prob=c(0.8, 0.2))

X.train <- X[split.idx,]
y.train <- y[split.idx]

X.test <- X[!split.idx,]
y.test <- y[!split.idx]
```

Lastly we fit a logistic regression model and evaluate our prediction in terms of classification accuracy:

```{r predict}

model <- cv.glmnet(X.train, y.train, family = 'binomial')
preds <- as.numeric(predict(model,X.test,type='class'))

accuracy <- sum(y.test ==preds)/length(y.test)
accuracy
```

